import ipaddress
import json
import logging
import sys
import os
import shutil
import socket
import sentry_sdk
import re

from pathlib import Path
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from time import sleep
from logging.handlers import RotatingFileHandler
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.common.exceptions import (
    NoSuchElementException,
    WebDriverException,
    ElementNotInteractableException,
    ElementClickInterceptedException
)
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from sentry_sdk.integrations.logging import LoggingIntegration

from channels_free import CHANNELS_FREE
from module_freeboxos import get_website_title
from security_sanitizer import global_sanitizer, scrub_event

CONFIG_PATH = Path("/home/seluser/.config/select_freeboxos/config.json")

try:
    with CONFIG_PATH.open(encoding="utf-8") as f:
        config = json.load(f)
except FileNotFoundError:
    print("ERROR: config.json not found", file=sys.stderr)
    sys.exit(1)
except json.JSONDecodeError as e:
    print(f"ERROR: invalid config.json: {e}", file=sys.stderr)
    sys.exit(1)

try:
    ADMIN_PASSWORD = config["ADMIN_PASSWORD"]
    FREEBOX_SERVER_IP = config["FREEBOX_SERVER_IP"]
    MEDIA_SELECT_TITLES = bool(config["MEDIA_SELECT_TITLES"])
    MAX_SIM_RECORDINGS = int(config["MAX_SIM_RECORDINGS"])
    HTTPS = bool(config["HTTPS"])
    SENTRY_MONITORING_SDK = bool(config["SENTRY_MONITORING_SDK"])
    CRYPTED_CREDENTIALS = bool(config.get("CRYPTED_CREDENTIALS", False))
    SECURITY_STRICT_MODE = bool(config.get("SECURITY_STRICT_MODE", True))
except KeyError as e:
    print(f"ERROR: missing config key: {e}", file=sys.stderr)
    sys.exit(1)

month_names_fr = {
    '01': 'Jan',
    '02': 'Fév',
    '03': 'Mar',
    '04': 'Avr',
    '05': 'Mai',
    '06': 'Juin',
    '07': 'Juil',
    '08': 'Août',
    '09': 'Sept',
    '10': 'Oct',
    '11': 'Nov',
    '12': 'Déc'
}

def translate_month(month_num):
    if month_num in month_names_fr:
        return month_names_fr[month_num]
    else:
        return "Mois invalide"

def cancel_record(driver):
    text_to_click = "Annuler"
    xpath = f"//span[text()='{text_to_click}']"
    cancel = driver.find_element(By.XPATH, xpath)
    cancel.click()
    sleep(5)

def find_element_with_retries(driver, by, value, retries=3, delay=1):
    """Try to find an element with retries."""
    for attempt in range(retries):
        try:
            return driver.find_element(by, value)
        except NoSuchElementException:
            logger.error(
                f"Attempt {attempt + 1}/{retries}: Le bouton programmer un enregistrement n'a pas été trouvé."
            )
            sleep(delay)
    logger.error(
        "Impossible de trouver le bouton programmer un enregistrement après plusieurs tentatives."
    )
    driver.quit()
    sys.exit(1)

def validate_video_title(title):
    """Validate video title"""
    sanitized_title = re.sub(r'[<>\'"]', '', title)
    if len(sanitized_title) > 200:
        sanitized_title = sanitized_title[:200]

    return sanitized_title

def is_private_address(hostname: str) -> bool:
    """
    Determine whether a hostname resolves to a private IP address.
    """
    try:
        ip = socket.gethostbyname(hostname)
        return ipaddress.ip_address(ip).is_private
    except Exception:
        return False

def classify_connection_context(hostname: str, https_enabled: bool) -> str:
    """
    Returns: 'local', 'remote_secure', 'remote_insecure'
    """
    private = is_private_address(hostname)

    if private and not https_enabled:
        return "local"

    if https_enabled:
        return "remote_secure"

    return "remote_insecure"

def enforce_security_policy(hostname: str, https_enabled: bool):
    context = classify_connection_context(hostname, https_enabled)

    if context == "remote_insecure":
        logger.critical(
            "Connexion HTTP détectée hors réseau local. "
            "Pour des raisons de sécurité, HTTPS est obligatoire "
            "lorsque l’ordinateur peut se trouver sur un réseau public."
        )
        sys.exit(1)

    if SECURITY_STRICT_MODE and context == "remote_secure":
        logger.warning(
            "Connexion distante détectée. "
            "Le mode sécurité stricte est activé : "
            "assurez-vous que l’ordinateur est de confiance."
        )

    logger.info("Contexte réseau détecté : %s", context)

def build_url(use_https, server_ip, path=""):
    """
    Safely construct URL.
    """
    protocol = "https://" if use_https else "http://"
    full_url = protocol + server_ip + path
    return full_url

if SENTRY_MONITORING_SDK:
    sentry_sdk.init(
        dsn="https://d8f2365db01e2b4afbb4a25f1157ec67@o4508778574381056.ingest.de.sentry.io/4508868363026512",
        traces_sample_rate=0,
        send_default_pii=False,
        include_local_variables=False,
        before_send=scrub_event,
    )
    if sentry_sdk.Hub.current.client and sentry_sdk.Hub.current.client.options.get("traces_sample_rate", 0) > 0:
        sentry_sdk.profiler.start_profiler()


log_file = "/var/log/select_freeboxos/select_freeboxos.log"
max_bytes = 10 * 1024 * 1024
backup_count = 5

log_handler = RotatingFileHandler(log_file, maxBytes=max_bytes, backupCount=backup_count)
log_format = '%(asctime)s %(levelname)s %(message)s'
log_datefmt = '%d-%m-%Y %H:%M:%S'
formatter = logging.Formatter(log_format, log_datefmt)

log_handler.setFormatter(formatter)

logger = logging.getLogger("module_freeboxos")
logger.addHandler(log_handler)

sentry_handler = logging.StreamHandler()
sentry_handler.setLevel(logging.WARNING)

sensitive_filter = global_sanitizer

log_handler.addFilter(sensitive_filter)
sentry_handler.addFilter(sensitive_filter)

sensitive_filter.update_patterns({
    "admin_password": ADMIN_PASSWORD,
    "freebox_ip": FREEBOX_SERVER_IP,
})

logger.addHandler(sentry_handler)
logger.setLevel(logging.INFO)

logging.basicConfig(level=logging.INFO,
                    format=log_format,
                    datefmt=log_datefmt,
                    handlers=[log_handler, sentry_handler])

if CRYPTED_CREDENTIALS:
    try:
        ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")
        FREEBOX_SERVER_IP = os.getenv("FREEBOX_SERVER_IP")

        if not FREEBOX_SERVER_IP or not ADMIN_PASSWORD:
            logger.error("Credentials not found by keyring.")
            sys.exit(1)
        sensitive_filter.update_patterns({
            "admin_password": ADMIN_PASSWORD,
            "freebox_ip": FREEBOX_SERVER_IP,
        })

    except Exception as e:
        logger.exception("An error occurred while retrieving credentials from keyring.")
        exit(1)

if HTTPS is False:
    url = "http://" + FREEBOX_SERVER_IP
    title = get_website_title(url)

    if title != "Freebox OS":
        logger.error(
            "Imposible to connect to the Freebox server. Exit programme."
        )
        sys.exit(1)

try:
    with open(
        "/home/seluser/.local/share/select_freeboxos"
        "/info_progs.json", "r", encoding='utf-8'
    ) as jsonfile:
        data_info_progs = json.load(jsonfile)
except FileNotFoundError:
    logger.error(
        "No info_progs.json file. Need to check curl command or "
        "internet connection. Exit programme."
    )
    sys.exit(1)
except json.JSONDecodeError:
    logger.error(
        "Invalid JSON data in info_progs.json file. The file may be empty or corrupted."
    )
    sys.exit(1)

try:
    with open(
        "/home/seluser/.local/share/select_freeboxos"
        "/progs_to_record.json", "r", encoding='utf-8'
    ) as jsonfile:
        data = json.load(jsonfile)
except FileNotFoundError:
    logger.error(
        "No progs_to_record.json file. Exit programme."
    )
    sys.exit(1)

if len(data) == 0 or len(data_info_progs) == 0:
    src_file = os.path.join(os.path.expanduser("~"), ".local", "share", "select_freeboxos", "info_progs.json")
    dst_file = os.path.join(os.path.expanduser("~"), ".local", "share", "select_freeboxos", "info_progs_last.json")
    shutil.copy(src_file, dst_file)
    logger.info("No data to record programmes. Exit programme.")
    sys.exit(1)


options = webdriver.FirefoxOptions()
options.add_argument("start-maximized")

try:
    with webdriver.Firefox(options=options) as driver:
        try:
            enforce_security_policy(FREEBOX_SERVER_IP, HTTPS)
            url = build_url(HTTPS, FREEBOX_SERVER_IP, "/login.php#Fbx.os.app.pvr.app")
            driver.get(url)
            sleep(8)
        except WebDriverException as e:
            if 'net::ERR_ADDRESS_UNREACHABLE' in e.msg:
                logger.error(
                    f"The programme cannot reach the address {FREEBOX_SERVER_IP} . Exit programme."
                )
                driver.quit()
                sys.exit(1)
            else:
                logger.error("A WebDriverException occurred. Exiting the program.")
                logger.error(f"Exception type: {type(e).__name__}")
                driver.quit()
                sys.exit(1)

        try:
            login = driver.find_element("id", "fbx-password")
        except Exception as e:
            logger.error(
                "Cannot connect to Freebox OS. Exit programme.", exc_info=False
            )
            driver.quit()
            sys.exit(1)
        sleep(1)
        login.click()
        sleep(1)
        login.send_keys(ADMIN_PASSWORD)
        ADMIN_PASSWORD = None
        sleep(1)
        login.send_keys(Keys.RETURN)
        sleep(10)

        try:
            invalid_password = driver.find_element(
                By.XPATH, "//div[contains(text(), 'Identifiants invalides')]"
            )
            logger.error(
                "Le mot de passe administrateur de la Freebox est invalide. "
                "La programmation des enregistrements n'a pas "
                "pu être réalisée. Merci de vérifier le mot de passe."
            )
            driver.quit()
            sys.exit(1)
        except NoSuchElementException:
            pass


        try:
            with open(
                "/home/seluser/.local/share/select_freeboxos"
                "/info_progs_last.json", "r", encoding='utf-8'
            ) as jsonfile:
                data_last = json.load(jsonfile)
        except FileNotFoundError:
            data_last = []

        starting = []

        for video in data_last:
            start = datetime.strptime(video["start"], "%Y%m%d%H%M").replace(
                tzinfo=ZoneInfo("Europe/Paris")
            )
            end = start + timedelta(seconds=video["duration"])

            starting.append((start, end))

        now_date = datetime.now().astimezone(ZoneInfo("Europe/Paris")).date()

        n = 0
        last_channel = "x/x"
        start_last = None

        for video in data:
            n += 1

            start = datetime.strptime(video["start"], "%Y%m%d%H%M").replace(
                tzinfo=ZoneInfo("Europe/Paris")
            )
            if start_last is not None and start == start_last:
                start += timedelta(minutes=1)

            start_last = start
            start_day = start.strftime("%d")
            start_date = start.date()
            start_month = start.strftime("%m")
            start_year = start.strftime("%y")
            start_hour = start.strftime("%H")
            start_minute = start.strftime("%M")

            end = start + timedelta(seconds=video["duration"])
            end_hour = end.strftime("%H")
            end_minute = end.strftime("%M")

            try:
                channel_number = CHANNELS_FREE[video["channel"]]
            except KeyError:
                logger.error(
                    "La chaine %s n'est pas présente dans le "
                    "fichier channels_free.py", video["channel"]
                )
                continue

            if len(starting) < MAX_SIM_RECORDINGS:
                starting.append((start, end))
                to_record = True
            else:
                if starting[-MAX_SIM_RECORDINGS][1] < start:
                    starting.append((start, end))
                    to_record = True
                else:
                    to_record = False

            if to_record:
                text_to_click = "Programmer un enregistrement"
                xpath = f"//span[text()='{text_to_click}']"
                programmer_enregistrements = find_element_with_retries(driver, By.XPATH, xpath)
                sleep(1)
                try:
                    programmer_enregistrements.click()
                except ElementClickInterceptedException as e:
                    logger.error("A ElementClickInterceptedException occurred.")
                    logger.error(
                        "Impossible de programmer les enregistrements. "
                        "Une fenêtre d'information empêche probablement "
                        "de pouvoir clicker sur le bouton programmer un "
                        "enregistrement."
                    )
                    driver.quit()
                    sys.exit(1)
                sleep(3)
                channel_uuid = driver.find_element("name", "channel_uuid")
                sleep(1)
                n = 0
                follow_record = True
                while channel_uuid.get_attribute("value").split("/")[0] != channel_number:
                    channel_uuid.clear()
                    sleep(1)
                    if last_channel.split("/")[0] != channel_number:
                        channel_uuid.send_keys(channel_number)
                    else:
                        channel_uuid.click()
                        sleep(1)
                        channel_uuid.clear()
                        sleep(3)
                        channel_uuid.send_keys(last_channel)
                        sleep(1)
                        channel_uuid.click()
                    sleep(1)
                    channel_uuid.send_keys(Keys.RETURN)
                    sleep(1)
                    last_channel = channel_uuid.get_attribute("value")
                    n += 1
                    if n > 10:
                        logger.error(
                            "Impossible de sélectionner la chaîne. Merci de "
                            "vérifier si la chaine n° %s qui "
                            "correspond à la chaine %s "
                            "de MEDIA-select est bien présente dans la liste des "
                            "chaines Freebox. ", channel_number, video["channel"]
                        )
                        follow_record = False
                        break
                if follow_record:
                    date = driver.find_element("name", "date")
                    date.click()
                    sleep(1)
                    day_difference = (start_date - now_date).days
                    if day_difference == 0:
                        text_to_click = "Aujourd"
                    elif day_difference == 1:
                        text_to_click = "Demain"
                    elif day_difference == 2:
                        text_to_click = "jours"
                    else:
                        text_to_click = start_day + " " + translate_month(start_month)
                    xpath = f"//li[contains(text(), '{text_to_click}') and not(contains(text(), 'TV'))]"
                    try:
                        day_click = driver.find_element(By.XPATH, xpath)
                    except NoSuchElementException as e:
                        logger.error("A NoSuchElementException occurred.")
                        logger.error(
                            "Impossible de trouver la date pour le programme %s. Le "
                            "programme ne sera pas enregistré.",
                            validate_video_title(video['title'])
                        )
                        cancel_record(driver)
                        continue
                    day_click.click()
                    sleep(1)
                    to_cancel = False
                    actual_start = "943463167"
                    loop_counter = 0
                    while True:
                        start_time = driver.find_element("name", "start_time")
                        start_time.clear()
                        sleep(0.5)
                        start_time.send_keys(start_hour + ":" + start_minute)
                        try:
                            WebDriverWait(driver, 10).until(
                                lambda d: start_time.get_attribute("value") == start_hour + ":" + start_minute
                            )
                        except:
                            logger.error("Timeout: The input field did not update to the correct time.")

                        actual_start = start_time.get_attribute("value")

                        if actual_start == start_hour + ":" + start_minute:
                            break
                        loop_counter += 1
                        if loop_counter > 4:
                            logger.error(
                                "Impossible de saisir l'heure de début pour le "
                                "programme %s. Le programme ne sera pas enregistré.",
                                validate_video_title(video['title'])
                            )
                            to_cancel = True
                            break
                    sleep(1)
                    start_time.send_keys(Keys.RETURN)
                    sleep(1)
                    actual_end = "943463167"
                    loop_counter = 0
                    while True:
                        end_time = driver.find_element("name", "end_time")
                        end_time.clear()
                        sleep(0.5)
                        end_time.send_keys(end_hour + ":" + end_minute)
                        try:
                            WebDriverWait(driver, 10).until(
                                lambda d: end_time.get_attribute("value") == end_hour + ":" + end_minute
                            )
                        except:
                            logger.error("Timeout: The input field did not update to the correct time.")

                        actual_end = end_time.get_attribute("value")

                        if actual_end == end_hour + ":" + end_minute:
                            break
                        loop_counter += 1
                        if loop_counter > 4:
                            logger.error(
                                "Impossible de saisir l'heure de fin pour le "
                                "programme %s. Le programme ne sera pas enregistré.",
                                validate_video_title(video['title'])
                            )
                            to_cancel = True
                            break
                    if to_cancel:
                        cancel_record(driver)
                    else:
                        sleep(1)
                        end_time.send_keys(Keys.RETURN)
                        sleep(1)
                        if MEDIA_SELECT_TITLES:
                            name_prog = driver.find_element("name", "name")
                            try:
                                name_prog.clear()
                                sleep(1)
                                name_prog.send_keys(validate_video_title(video["title"]))
                                sleep(1)
                            except ElementNotInteractableException:
                                logger.error(
                                    "Une ElementNotInteractableException est apparue. "
                                    "Le titre de MEDIA select ne sera pas utilisé pour "
                                    "nommer le vidéo."
                                )
                        text_to_click = "Sauvegarder"
                        xpath = f"//span[text()='{text_to_click}']"
                        sauvegarder = driver.find_element(By.XPATH, xpath)
                        sauvegarder.click()
                        sleep(5)
                        try:
                            internal_error = driver.find_element(
                                By.XPATH, "//div[contains(text(), 'Erreur interne')]"
                            )
                            logger.error(
                                "Une erreur interne de la Freebox est survenue. "
                                "La programmation des enregistrements n'a pas "
                                "pu être réalisée. Merci de vérifier si le disque "
                                "dur n'est pas plein."
                            )
                            break
                        except NoSuchElementException:
                            pass
                else:
                    cancel_record(driver)

        sleep(6)
        driver.quit()

        src_file = os.path.join(os.path.expanduser("~"), ".local", "share", "select_freeboxos", "info_progs.json")
        dst_file = os.path.join(os.path.expanduser("~"), ".local", "share", "select_freeboxos", "info_progs_last.json")
        shutil.copy(src_file, dst_file)
except Exception as e:
    logger.error("An unexpected error occurred:")
    logger.error("Exception type: %s", type(e).__name__)
    logger.error("Exception message: %s", str(e)[:100])
